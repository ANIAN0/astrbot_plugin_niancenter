当前项目是astrbot的插件模板，我希望开发一个插件，具备以下功能：
1. 监听私聊消息的关键字，根据不同的关键字调用不同的接口，根据接口返回内容进行回复
- 根据本地json文件配置，监听私聊消息的关键字，调用对应接口，将接口返回内容根据配置的消息类型，组装消息进行回复。支持文本，图片，视频，语音
- 本地json文件配置关键词、请求的url、请求参数、回复消息类型
- 当关键字触发时，通过event.unified_msg_origin获取本次会话的标识，在本地存储unified_msg_origin、session_id、group_id、sender，用于后续的主动消息
AstrMessageEvent 是 AstrBot 的消息事件对象，其中存储了消息发送者、消息内容等信息。
AstrBotMessage 是 AstrBot 的消息对象，其中存储了消息平台下发的消息具体内容，AstrMessageEvent 对象中包含一个 message_obj 属性用于获取该消息对象。
class AstrBotMessage:
    '''AstrBot 的消息对象'''
    type: MessageType  # 消息类型
    self_id: str  # 机器人的识别id
    session_id: str  # 会话id。取决于 unique_session 的设置。
    message_id: str  # 消息id
    group_id: str = "" # 群组id，如果为私聊，则为空
    sender: MessageMember  # 发送者
    message: List[BaseMessageComponent]  # 消息链。比如 [Plain("Hello"), At(qq=123456)]
    message_str: str  # 最直观的纯文本消息字符串，将消息链中的 Plain 消息（文本消息）连接起来
    raw_message: object
    timestamp: int  # 消息时间戳
2. 提供对外接口，可通过调用接口，给指定用户发送私聊消息
- 调用接口时，需要提供unified_msg_origin，用于指定发送消息的会话
- 消息支持文本，图片，视频，语音

请你先帮我设计项目的结构，我希望能够将每个功能独立一个文件，这样结构更清晰更容易理解

因为你不看我提供的url，我决定换一种方式提供参考，如果你还需要什么信息，请直接告诉我，我来给你提供

项目1：统一的API调用插件https://github.com/Zhalslar/astrbot_plugin_apis
main.py插件入口文件，定义APIsPlugin类，实现：
初始化插件（加载配置、API 管理器、本地数据管理器、网络请求管理器）
消息事件处理（匹配 API 触发词、补充参数、调用 API、发送响应）
核心命令实现（api列表、api详情、添加api、删除api、api测试等）
API 调用流程（优先网络请求，失败时使用本地缓存）
资源清理（终止时关闭网络会话）
core/api_manager.py管理 API 配置的核心模块：
从system_api.json和user_api.json加载 API 配置
提供 API 匹配（通过触发词查找对应的 API 配置）
支持 API 的添加、删除、详情查询
解析用户输入的 API 配置字符串为字典格式
core/local.py本地数据管理模块：
初始化数据存储目录（按 API 类型分目录存储）
保存 API 返回的文本 / 二进制数据（图片、视频、音频）
读取本地缓存数据（作为网络请求失败时的兜底）
core/request.py网络请求处理模块：
基于aiohttp发送异步 HTTP 请求，支持多 URL 重试
自动解析响应数据（JSON、文本、二进制、HTML）
批量测试 API 可用性（按站点分组并发测试）
处理 API 密钥、请求头模拟等细节
流程说明：
用户发送消息后，插件先判断消息是否匹配某个 API 的触发词
匹配成功后，检查该 API 是否被禁用或类型是否在允许列表中
提取消息中的参数，若参数不足则自动补充（如从回复消息、@用户中提取）
优先调用网络 API 获取数据，成功则保存到本地；失败则使用本地缓存的历史数据
根据 API 类型（文本 / 图片 / 视频 / 音频）生成对应的消息链并发送给用户
若配置了不自动保存数据，则发送后清理临时文件

项目2：主动消息插件https://github.com/DBJD-CR/astrbot_plugin_proactive_chat
# 插件安装目录
AstrBot/
└─ data/
   └─ plugins/
      └─ astrbot_plugin_proactive_chat/
         ├─ _conf_schema.json       # 配置schema定义
         ├─ logo.png                # 插件图标
         ├─ main.py                 # 核心功能实现
         ├─ metadata.yaml           # 插件元数据
         ├─ README.md               # 文档说明
         └─ requirements.txt        # 依赖项列表

# 数据存储目录（运行时生成）
AstrBot/
└─ data/
   └─ plugin_data/
      └─ astrbot_plugin_proactive_chat/
         └─ session_data.json       # 会话数据持久化文件
2. 核心处理流程
私聊流程：
取消旧定时任务
重置未回复计数器
通过 APScheduler 调度新任务
任务触发后检查条件
加载上下文与人格设定
调用 LLM 生成主动消息
发送消息并更新会话数据
群聊流程：
重置沉默倒计时
清理过期数据
检测 Bot 消息
通过 asyncio.TimerHandle 实现定时
满足沉默阈值后触发主动消息
动态调整后续策略
三、核心文件说明
main.py
插件核心功能实现文件
包含事件处理函数（私聊 / 群聊消息监听、消息发送后处理）
实现定时任务调度（APScheduler/asyncio.TimerHandle）
处理 LLM 调用与消息生成逻辑
管理会话数据的持久化与恢复
_conf_schema.json
定义插件配置项结构
支持通过 WebUI 进行可视化配置
包含会话相关参数、时间间隔设置等
session_data.json（运行时生成）
存储会话状态数据
通过 aiofiles 实现异步 I/O 操作
使用 asyncio.Lock 保证并发安全
包含未回复计数、任务状态等关键信息
metadata.yaml
插件元数据描述
包含插件名称、版本、作者、兼容 AstrBot 版本等信息
用于 AstrBot 插件市场展示与管理
requirements.txt
声明插件依赖的 Python 包
确保运行环境的一致性

项目3：智能定时任务插件https://github.com/kjqwer/astrbot_plugin_sy
配置相关：_conf_schema.json（配置项 schema 定义）、metadata.yaml（插件元信息）
核心逻辑：main.py（插件主类实现）、scheduler.py（任务调度管理）、reminder_handlers.py（提醒处理辅助）
命令处理：commands.py（命令定义）、command_trigger.py（命令触发）、command_utils.py（命令处理工具）
数据与工具：utils.py（通用工具函数，含节假日处理）、tools.py（插件工具类）、qq_id_cache.py（QQ 号缓存）、event_factory.py（事件工厂）
说明文档：README.md（插件说明）、.gitignore（Git 忽略配置）
主要流程
初始化流程
插件启动时，main.py 中的 SmartReminder 类初始化，处理数据文件路径（兼容新旧路径并迁移数据），加载配置（如会话隔离、@功能开关等）。
初始化调度器（ReminderScheduler）、工具类（ReminderTools）、命令处理器（ReminderCommands）及节假日管理器（HolidayManager）。
任务创建流程
通过自然语言交互或命令（如 /rmd add、/rmd task）触发任务创建。
command_utils.py 中的 UnifiedCommandProcessor 统一处理参数解析、时间验证、重复规则设置等逻辑。
生成任务数据并保存到 reminder_data.json，同时通过调度器注册定时任务。
任务执行流程
调度器（scheduler.py）根据时间触发任务，调用 reminder_handlers.py 中的处理逻辑。
结合节假日管理器（utils.py 中的 HolidayManager）判断是否符合执行条件（如仅工作日执行）。
执行对应操作（发送提醒、执行指令等），并根据配置决定是否 @ 创建者。
任务管理流程
通过命令（如 /rmd ls 查看、/rmd rm 删除）触发管理操作，工具类（tools.py）处理数据查询与修改，同步更新调度器和数据文件。
核心文件
main.py
定义插件主类 SmartReminder，负责插件初始化、配置加载、工具与调度器实例化。
注册 LLM 工具函数（set_reminder_or_task、delete_reminder_or_task 等），对接自然语言交互。
scheduler.py
实现任务调度管理，负责定时任务的添加、删除和触发，确保任务在指定时间执行。
command_utils.py
提供统一的命令处理逻辑（UnifiedCommandProcessor），整合任务创建的参数验证、时间解析、数据存储等通用步骤。
utils.py
包含节假日管理（HolidayManager），处理法定节假日和工作日判断，支持数据缓存与更新。
提供时间解析、数据加载 / 保存等通用工具函数。
_conf_schema.json
定义插件可配置项（如会话隔离、@功能开关、最大提醒数等），规范配置格式与默认值。

一、
1. 定时轮询云端接口https://hunian003-message.hf.space/plugins/astr_task_center/api/tasks，获取未同步的主动消息任务列表，
查询参数，
task_type - 任务类型过滤 (active_message)
synced - 是否同步过滤 (false)
created_after - 创建时间起始（含）ISO 8601 格式
created_before - 创建时间结束（含）ISO 8601 格式。
如果有新的任务，将任务保存到插件目录下的任务列表的json文件内，调用接口https://hunian003-message.hf.space/plugins/astr_task_center/api/tasks/{task_id}/synced，入参{ "synced": true }，将任务更新为已同步。
2. 定时检查本地任务列表任务类型是active_message，执行时间在过去5分钟内，执行状态为未执行的任务
触发任务执行，根据任务内容发送主动消息。{
  "unified_msg_origin": "助手bot:FriendMessage:724611902",
  "type": "text",
  "context": "你好"
}
type是消息类型，context是消息内容。支持文本、图片、语音、视频、文件等类型。
执行后，调用接口https://hunian003-message.hf.space/plugins/astr_task_center/api/tasks/{task_id}/status，入参：
    {
        "status": "pending" | "running" | "success" | "failed",
        "result": {...} (可选)
    }，更新任务的状态和结果success/failed，failed需要更新result填写失败原因
接口调用时，需要携带Authorization头，值需要从本地配置文件中获取
二、
1. 定时轮询云端接口https://hunian003-message.hf.space/plugins/astr_task_center/api/tasks，获取未同步的本地存储任务列表，
查询参数，
task_type - 任务类型过滤 (local_storage)
synced - 是否同步过滤 (false)
created_after - 创建时间起始（含）ISO 8601 格式
created_before - 创建时间结束（含）ISO 8601 格式。
如果有新的任务，将任务保存到插件目录下的任务列表的json文件内，调用接口https://hunian003-message.hf.space/plugins/astr_task_center/api/tasks/{task_id}/synced，入参{ "synced": true }，将任务更新为已同步。
2. 定时检查本地任务列表任务类型是active_message，执行时间在过去5分钟内，执行状态为未执行的任务
触发任务执行，根据任务内容将context的内容保存到本地{
  "type": "text",
  "context": "测试"
}
type是消息类型，context是消息内容。支持文本、图片、语音、视频、文件等类型。图片、语音、视频、文件可能是url，也可能是base64编码。
执行后，调用接口https://hunian003-message.hf.space/plugins/astr_task_center/api/tasks/{task_id}/status，入参：
    {
        "status": "pending" | "running" | "success" | "failed",
        "result": {...} (可选)
    }，更新任务的状态和结果success/failed，failed需要更新result填写失败原因
接口调用时，需要携带Authorization头，值需要从本地配置文件中获取
三、
1. 发送主动消息，如果type是image、voice、video、file，将context的内容保存到本地（插件文件夹下，按类型分别存放）后，再用本地文件的方式发送主动消息
2. 之前功能调用API后将API结果进行回复，需要增加逻辑，当reply_type是image、voice、video、file时，将回复结果缓存到本地（插件文件夹下，按类型分别存放）后，用本地文件的方式发送回复

四、注意处理报错，确保程序的健壮性
